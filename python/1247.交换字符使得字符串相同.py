#
# @lc app=leetcode.cn id=1247 lang=python3
#
# [1247] 交换字符使得字符串相同
#
# 解法1(错误)：看了题目上方的提示，但每太十分理解。同时遍历两字符串，分四种情况：1）如果二者相等就不用动了；2）如果是xx yy这样的两对则一次交换即可；3）如果是xy yx这样的两对则两次交换；4）否则就往后找第一个能使得当前第i位匹配上的下标j，注意s1 s2都要找。这个解法的问题在于如果只是往后找一个能匹配的，可能是局部最优解，而且拆除了后面的匹配，可能之后就救不回来了
# 
# 解法2(T75% S88%)：贪心，已经超出了能做出来的认知了。二者不能匹配要交换无非是因为二者当前是xy对或者yx对，我们可以直接一次同时遍历两字符串，并统计xy和yx出现的频次。而不论这两个不匹配情况在哪出现，最终都是靠示例1和2来解决，也就是通过一次交换使两对xy-xy或者两对yx-yx处理完成，或者通过两次交换来处理xy-yx对。因此相当于每两个xy都可以组成连续的xy-xy，用一次交换来解决，而落单的xy只能找另一个落单的yx通过两次交换来解决。因此只需要对统计好的xy和yx分别计算整除2的个数以及剩下的余数加起来就好，而如果xy和yx的总对数只有奇数个话，最终一定会剩下一对无法交换，此时返回-1

# @lc code=start
class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        xy, yx = 0, 0
        for a, b in zip(s1, s2):
            if a=='x' and b=='y':
                xy += 1
            elif a=='y' and b=='x':
                yx += 1
        if (xy + yx) % 2 == 1:
            return -1
        return xy//2 + yx//2 + xy%2 + yx%2
# @lc code=end

