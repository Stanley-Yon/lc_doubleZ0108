#
# @lc app=leetcode.cn id=1144 lang=python3
#
# [1144] 递减元素使数组呈锯齿状
#
# 解法1(解答错误)：因为锯齿只有两种可能，A字形和V字形，所以不妨把这两种都做一下。以V字形为例，从下标2开始循环，判断i-2 i-1 i三个数的大小，如果正好满足V字则不需要操作，否则有两种可能：1）把i-1位变成周围两个数的最小值-1；2）把i-2和i变成比i-1大的数，如果数组结尾还有一个单独的数则要单独考虑它的大小。这两个可能性哪个操作数少就用哪个，整个题再从V字和A字整体中选最小的
#     问题在于不一定这样三个三个匹配有最小值，i元素还要关联下面的i+2那里的判断，所以这样的方法求的是局部最小值，[2,7,10,9,8,9]例子就无法通过
#
# 解法2(解答错误)：解法1没看到题里说只能减不能加，因此不妨从1开始一个一个遍历，也是分A和V两种情况，通过flag来表示交替递增和递减，如果不满足当前flag表示的顺序则修改数组并统计
#     问题在于0号元素的修改可能更划算，[10,4,4,10,10,6,2,3]例子无法通过
#    
# 解法3(T46% S92%)：思路跟解法1和解法2很像，证明自己想的大方向是没问题的，即贪心+A V分类讨论，按具体实现上自己总是太关注细节，而贪心的答案总是不关注细节直接贪，看来自己对贪心的理解还不够深。本题的官方题解本质上就是说分两种情况：要么奇数项都一定比偶数项大，要么反过来，总归是中间的下标要比旁边两个人都大，因此只统计这个差值的最大值就够了

# @lc code=start
class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
        def forloop(start):
            res = 0
            for i in range(start, len(nums), 2):
                tmp = 0
                if i-1>=0:
                    tmp = max(tmp, nums[i]-nums[i-1]+1)
                if i+1<len(nums):
                    tmp = max(tmp, nums[i]-nums[i+1]+1)
                res += tmp
            return res

        return min(forloop(0), forloop(1))
# @lc code=end

